<?php

declare(strict_types=1);

namespace LaunchDarkly;

use LaunchDarkly\Impl\Model\FeatureFlag;

/**
 * A snapshot of the state of all feature flags with regard to a specific user.
 *
 * This is generated by calling {@see \LaunchDarkly\LDClient::allFlagsState()}.
 *
 * Serializing this object to JSON using json_encode(), or the jsonSerialize() method, will produce the
 * appropriate data structure for bootstrapping the LaunchDarkly JavaScript client. See the SDK
 * reference guide on ["Bootstrapping"](https://docs.launchdarkly.com/sdk/features/bootstrapping#javascript).
 */
class FeatureFlagsState implements \JsonSerializable
{
    protected bool $_valid = false;
    protected array $_flagValues;
    protected array $_flagMetadata;

    /**
     * @ignore
     */
    public function __construct(bool $valid)
    {
        $this->_valid = $valid;
        $this->_flagValues = [];
        $this->_flagMetadata = [];
    }

    /**
     * Used internally to build the state map.
     *
     * @ignore
     *
     * @return void
     */
    public function addFlag(
        FeatureFlag $flag,
        EvaluationDetail $detail,
        bool $forceReasonTracking = false,
        bool $withReason = false,
        bool $detailsOnlyIfTracked = false
    ): void {
        $this->_flagValues[$flag->getKey()] = $detail->getValue();
        $meta = [];

        $trackEvents = $flag->isTrackEvents() || $forceReasonTracking;
        $trackReason = $forceReasonTracking;

        $omitDetails = false;
        if ($detailsOnlyIfTracked) {
            if (!$trackEvents && !$trackReason && !$flag->getDebugEventsUntilDate()) {
                $omitDetails = true;
            }
        }

        $reason = (!$withReason && !$trackReason) ? null : $detail->getReason();

        if ($reason && !$omitDetails) {
            $meta['reason'] = $reason;
        }
        if (!$omitDetails) {
            $meta['version'] = $flag->getVersion();
        }
        if (!is_null($detail->getVariationIndex())) {
            $meta['variation'] = $detail->getVariationIndex();
        }
        if ($trackEvents) {
            $meta['trackEvents'] = true;
        }
        if ($trackReason) {
            $meta['trackReason'] = true;
        }
        if ($flag->getDebugEventsUntilDate()) {
            $meta['debugEventsUntilDate'] = $flag->getDebugEventsUntilDate();
        }
        $this->_flagMetadata[$flag->getKey()] = $meta;
    }

    /**
     * Returns true if this object contains a valid snapshot of feature flag state, or false if the
     * state could not be computed (for instance, because the client was offline or there was no user).
     * @return bool true if the state is valid
     */
    public function isValid(): bool
    {
        return $this->_valid;
    }

    /**
     * Returns the value of an individual feature flag at the time the state was recorded.
     * @param string $key the feature flag key
     * @return mixed the flag's value; null if the flag returned the default value, or if there was no such flag
     */
    public function getFlagValue(string $key): mixed
    {
        return $this->_flagValues[$key] ?? null;
    }

    /**
     * Returns the evaluation reason for an individual feature flag (as returned by variationDetail())
     * at the time the state was recorded.
     * @param string $key the feature flag key
     * @return EvaluationReason|null the evaluation reason; null if reasons were not recorded, or if there
     * was no such flag
     * @see \LaunchDarkly\LDClient::variationDetail()
     */
    public function getFlagReason(string $key): ?EvaluationReason
    {
        return ($this->_flagMetadata[$key] ?? [])['reason'] ?? null;
    }

    /**
     * Returns an associative array of flag keys to flag values.
     *
     * If a flag would have evaluated to the default value, its value will be null.
     *
     * Do not use this method if you are passing data to the front end to "bootstrap" the JavaScript client.
     * Instead, use jsonSerialize().
     * @return array an associative array of flag keys to JSON values
     */
    public function toValuesMap(): array
    {
        return $this->_flagValues;
    }

    /**
     * Returns a JSON representation of the entire state map (as an associative array), in the format used
     * by the LaunchDarkly JavaScript SDK.
     *
     * Use this method if you are passing data to the front end in order to "bootstrap" the JavaScript client.
     *
     * Note that calling json_encode() on a FeatureFlagsState object will automatically use the
     * jsonSerialize() method.
     * @return array an associative array suitable for passing as a JSON object
     */
    public function jsonSerialize(): array
    {
        $ret = array_replace([], $this->_flagValues);
        if (count($this->_flagMetadata) === 0) {
            $metaMap = new \stdClass(); // using object rather than array ensures the JSON value is {}, not []
        } else {
            $metaMap = [];
            foreach ($this->_flagMetadata as $key => $meta) {
                $meta = array_replace([], $meta);
                if ($meta['reason'] ?? null) {
                    $meta['reason'] = $meta['reason']->jsonSerialize();
                }
                $metaMap[$key] = $meta;
            }
        }
        $ret['$flagsState'] = $metaMap;
        $ret['$valid'] = $this->_valid;
        return $ret;
    }
}
